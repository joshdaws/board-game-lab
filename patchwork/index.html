<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Patchwork</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f5efe6;
    --bg-warm: #ede4d6;
    --surface: #ffffff;
    --surface-alt: #faf6f0;
    --border: #e0d5c5;
    --border-strong: #c4b8a8;
    --text: #2c2419;
    --text-secondary: #7a6f62;
    --text-muted: #a89e90;
    --accent: #c45d3e;
    --accent-hover: #a84830;
    --accent-light: #f7e8e3;
    --p1: #3b8686;
    --p1-light: #e4f0f0;
    --p1-bg: #d1e8e8;
    --p2: #c45d3e;
    --p2-light: #f7e8e3;
    --p2-bg: #f0d8cf;
    --gold: #c49a3c;
    --gold-light: #fdf4de;
    --green: #5a9a5a;
    --green-light: rgba(90,154,90,0.2);
    --red-light: rgba(196,60,60,0.15);
    --empty-cell: #ebe5db;
    --empty-cell-hover: #ddd6ca;
    --grid-gap: #d4cbbf;
    --special-patch: #8b7355;
    --shadow-sm: 0 1px 3px rgba(44,36,25,0.08);
    --shadow-md: 0 4px 12px rgba(44,36,25,0.1);
    --shadow-lg: 0 8px 24px rgba(44,36,25,0.12);
    --radius-sm: 6px;
    --radius-md: 10px;
    --radius-lg: 16px;
    --cell-size: 36px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
  }

  #app {
    max-width: 1100px;
    margin: 0 auto;
    padding: 16px;
  }

  /* ── Header ─── */
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }
  .header-left { display: flex; align-items: baseline; gap: 12px; }
  .logo {
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--text);
    letter-spacing: -0.5px;
  }
  .turn-badge {
    font-size: 0.8rem;
    font-weight: 600;
    padding: 4px 12px;
    border-radius: 20px;
    transition: all 0.3s;
  }
  .turn-badge.p0 { background: var(--p1-bg); color: var(--p1); }
  .turn-badge.p1 { background: var(--p2-bg); color: var(--p2); }
  .btn {
    font-family: inherit;
    font-size: 0.85rem;
    font-weight: 600;
    padding: 8px 16px;
    border: none;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn-primary {
    background: var(--accent);
    color: #fff;
  }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-primary:disabled { background: #c4b8a8; cursor: not-allowed; }
  .btn-secondary {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { background: var(--bg-warm); }
  .btn-ghost {
    background: transparent;
    color: var(--text-secondary);
  }
  .btn-ghost:hover { background: var(--bg-warm); }

  /* ── Time Track ─── */
  .track-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: 12px 16px;
    margin-bottom: 16px;
    box-shadow: var(--shadow-sm);
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  .track-row {
    display: flex;
    gap: 2px;
    min-width: fit-content;
  }
  .tc {
    width: 16px;
    height: 28px;
    border-radius: 3px;
    position: relative;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    font-size: 0;
    background: var(--bg-warm);
    flex-shrink: 0;
  }
  .tc.income { background: var(--gold-light); border: 1px solid #e8d49e; }
  .tc.special { background: var(--accent-light); border: 1px solid #e8bfb2; }
  .tc:nth-child(10n+1) .tc-num { display: block; }
  .tc:last-child .tc-num { display: block; }
  .tc-num {
    display: none;
    position: absolute;
    bottom: -14px;
    font-size: 0.55rem;
    color: var(--text-muted);
    white-space: nowrap;
  }
  .tk {
    position: absolute;
    top: -4px;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: var(--shadow-sm);
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.5rem;
    font-weight: 800;
    color: #fff;
  }
  .tk.t0 { background: var(--p1); left: -2px; }
  .tk.t1 { background: var(--p2); right: -2px; }

  /* ── Game Area ─── */
  .game-area {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 16px;
  }

  /* ── Player Panel ─── */
  .panel {
    background: var(--surface);
    border: 2px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 16px;
    box-shadow: var(--shadow-sm);
    transition: border-color 0.3s, box-shadow 0.3s;
  }
  .panel.active { box-shadow: var(--shadow-md); }
  .panel.active.p0 { border-color: var(--p1); }
  .panel.active.p1 { border-color: var(--p2); }
  .panel-head {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  .pname {
    font-weight: 700;
    font-size: 0.95rem;
  }
  .panel.p0 .pname { color: var(--p1); }
  .panel.p1 .pname { color: var(--p2); }
  .pstats {
    display: flex;
    gap: 10px;
    font-size: 0.75rem;
    color: var(--text-secondary);
    flex-wrap: wrap;
  }
  .pstat {
    display: flex;
    align-items: center;
    gap: 3px;
    font-weight: 500;
  }
  .pstat-icon {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.6rem;
    font-weight: 700;
    color: #fff;
  }
  .pstat-icon.btn-icon { background: var(--gold); }
  .pstat-icon.inc-icon { background: var(--green); }
  .pstat-icon.empty-icon { background: var(--text-muted); }

  /* ── Quilt Board ─── */
  .board-wrap {
    display: flex;
    justify-content: center;
  }
  .board {
    display: grid;
    grid-template-columns: repeat(9, var(--cell-size));
    gap: 2px;
    padding: 4px;
    background: var(--grid-gap);
    border-radius: var(--radius-sm);
  }
  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    border-radius: 3px;
    transition: background 0.12s, transform 0.1s;
    position: relative;
  }
  .cell.empty-cell { background: var(--empty-cell); }
  .cell.preview-ok {
    background: var(--green-light) !important;
    outline: 2px solid var(--green);
    outline-offset: -2px;
  }
  .cell.preview-bad {
    background: var(--red-light) !important;
    outline: 2px solid rgba(196,60,60,0.4);
    outline-offset: -2px;
  }
  .cell.preview-income {
    background: var(--gold-light) !important;
    outline: 2px solid var(--gold);
    outline-offset: -2px;
  }
  .cell.clickable {
    cursor: pointer;
    outline: 2px dashed var(--green);
    outline-offset: -2px;
  }
  .cell.clickable:hover {
    background: var(--green-light) !important;
    transform: scale(1.05);
  }
  .cell .btn-dot {
    position: absolute;
    top: 3px;
    right: 3px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--gold);
    border: 1px solid rgba(255,255,255,0.6);
  }

  /* ── Market ─── */
  .market-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: 14px 16px;
    margin-bottom: 16px;
    box-shadow: var(--shadow-sm);
  }
  .market-head {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  .market-title {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-secondary);
  }
  .market-count {
    font-size: 0.7rem;
    color: var(--text-muted);
  }
  .market-row {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding-bottom: 4px;
    -webkit-overflow-scrolling: touch;
  }
  .mpatch {
    flex-shrink: 0;
    padding: 8px;
    border-radius: var(--radius-sm);
    border: 2px solid transparent;
    background: var(--surface-alt);
    opacity: 0.35;
    transition: all 0.2s;
    cursor: default;
    position: relative;
  }
  .mpatch.avail {
    opacity: 1;
    border-color: var(--border-strong);
    cursor: pointer;
  }
  .mpatch.avail:hover {
    border-color: var(--accent);
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
  }
  .mpatch.avail.no-afford {
    opacity: 0.5;
    cursor: not-allowed;
    border-color: var(--border);
  }
  .mpatch.avail.no-fit {
    opacity: 0.4;
    cursor: not-allowed;
    border-color: var(--border);
  }
  .mpatch.avail.no-afford:hover,
  .mpatch.avail.no-fit:hover {
    transform: none;
    box-shadow: none;
    border-color: var(--border);
  }
  .mpatch .pawn-tag {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.55rem;
    font-weight: 700;
    text-transform: uppercase;
    color: var(--gold);
    background: var(--surface);
    padding: 1px 6px;
    border-radius: 4px;
    border: 1px solid var(--gold);
    letter-spacing: 0.5px;
  }
  .mshape {
    display: grid;
    gap: 2px;
    margin-bottom: 6px;
  }
  .mcell {
    width: 14px;
    height: 14px;
    border-radius: 2px;
  }
  .mcell.empty { background: transparent; }
  .minfo {
    font-size: 0.65rem;
    color: var(--text-secondary);
    text-align: center;
    line-height: 1.3;
    font-weight: 500;
  }
  .minfo .cost { color: var(--text); }
  .minfo .income-tag {
    display: inline-block;
    background: var(--gold-light);
    color: var(--gold);
    padding: 0 4px;
    border-radius: 3px;
    font-weight: 700;
    font-size: 0.6rem;
  }

  /* ── Action Bar ─── */
  .action-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: 14px 20px;
    box-shadow: var(--shadow-sm);
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    min-height: 56px;
  }
  .action-msg {
    flex: 1;
    font-size: 0.9rem;
    font-weight: 500;
    min-width: 150px;
  }
  .placement-bar {
    display: flex;
    gap: 6px;
    align-items: center;
    flex-wrap: wrap;
  }
  .placement-bar .btn { font-size: 0.8rem; padding: 6px 12px; }
  .key-badge {
    font-size: 0.6rem;
    background: var(--bg-warm);
    color: var(--text-muted);
    padding: 1px 5px;
    border-radius: 3px;
    margin-left: 3px;
    font-weight: 600;
  }

  /* ── Game Over ─── */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(44,36,25,0.6);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    animation: fadeIn 0.3s ease;
  }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  .over-card {
    background: var(--surface);
    border-radius: var(--radius-lg);
    padding: 36px 48px;
    text-align: center;
    box-shadow: var(--shadow-lg);
    border: 2px solid var(--border);
    animation: scaleIn 0.3s ease;
  }
  @keyframes scaleIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
  .over-card h2 {
    font-size: 1.6rem;
    font-weight: 800;
    margin-bottom: 20px;
  }
  .score-tbl {
    margin: 0 auto 20px;
    border-collapse: collapse;
    font-size: 0.85rem;
  }
  .score-tbl th {
    color: var(--text-muted);
    font-weight: 600;
    font-size: 0.7rem;
    text-transform: uppercase;
    padding: 4px 20px;
  }
  .score-tbl td { padding: 4px 20px; }
  .score-tbl .total-row td {
    font-weight: 800;
    font-size: 1.15rem;
    padding-top: 8px;
    border-top: 2px solid var(--border);
  }

  /* ── Setup ─── */
  .setup {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 85vh;
    gap: 28px;
  }
  .setup-logo {
    font-size: 3rem;
    font-weight: 800;
    letter-spacing: -1px;
    color: var(--text);
  }
  .setup-sub {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-top: -20px;
  }
  .setup-form {
    display: flex;
    flex-direction: column;
    gap: 14px;
    width: 280px;
  }
  .setup-form label {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .setup-form select {
    width: 100%;
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    padding: 10px 12px;
    border-radius: var(--radius-sm);
    font-family: inherit;
    font-size: 0.9rem;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%237a6f62' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
  }
  .setup-form .btn {
    margin-top: 6px;
    padding: 12px;
    font-size: 1rem;
  }

  /* ── Responsive ─── */
  @media (max-width: 860px) {
    :root { --cell-size: 30px; }
    .game-area { grid-template-columns: 1fr; }
    .panel { padding: 12px; }
  }
  @media (max-width: 500px) {
    :root { --cell-size: 26px; }
    #app { padding: 10px; }
    .board { gap: 1px; padding: 3px; }
    .tc { width: 12px; height: 22px; }
  }
</style>
</head>
<body>
<div id="app"></div>

<script type="module">
import {
  createGame, getActivePlayer, getAvailablePatches,
  findValidPlacements, canPlace,
  actionAdvance, actionBuyPatch, confirmPlacement,
  placeSpecialPatch, getScoreBreakdown, countEmpty,
  flipShape, getOrientations,
} from './engine.js';
import { BUTTON_INCOME_AFTER, SPECIAL_PATCH_AFTER } from './patches.js';
import { executeAIMove, aiPlaceSpecialPatch } from './ai.js';

// ── Patch Color Palette (warm fabric hues) ───────────────────

const FABRIC_COLORS = [
  '#d4837a','#e6a96b','#c4b06e','#8ab87e','#6db3a0',
  '#6daab3','#7a9ec4','#9b8cc4','#c48ab3','#d48a8a',
  '#c9976b','#a3b86b','#6bb89b','#6ba8c9','#8b7ec4',
  '#c47eb3','#d4a07a','#b8c46b','#6bc4a0','#6b98c4',
  '#a06bc4','#c46b8a','#d4b87a','#8ac46b','#6bc4c4',
  '#6b7ec4','#b86bc4','#c46b6b','#c4a86b','#6bc48a',
  '#6bb8c4','#8a6bc4','#c46ba0',
];
const SPECIAL_COLOR = '#a08060';

// ── App State ────────────────────────────────────────────────

let game = null;
let appMode = 'setup';
let gameMode = 'vs-ai';
let aiDifficulty = 'medium';

// Per-cell color tracking for quilt rendering
let colorBoards = [null, null];

// Placement state
let placingPatch = null;
let placingShape = null;
let placingRow = 0;
let placingCol = 0;
let placingOrientIdx = 0;
let placingOrients = [];
let placingValid = false;

const app = document.getElementById('app');

// ── DOM Helper ───────────────────────────────────────────────

function h(tag, attrs, ...children) {
  const e = document.createElement(tag);
  if (attrs) for (const [k, v] of Object.entries(attrs)) {
    if (k === 'cls') e.className = v;
    else if (k === 'style' && typeof v === 'object') Object.assign(e.style, v);
    else if (k.startsWith('on')) e[k] = v;
    else if (k.startsWith('data')) e.setAttribute(k.replace(/([A-Z])/g, '-$1').toLowerCase(), v);
    else e.setAttribute(k, v);
  }
  for (const ch of children) {
    if (ch == null || ch === false) continue;
    if (typeof ch === 'string' || typeof ch === 'number')
      e.appendChild(document.createTextNode(String(ch)));
    else if (Array.isArray(ch)) ch.forEach(c => { if (c) e.appendChild(c); });
    else e.appendChild(ch);
  }
  return e;
}

function patchColor(patchId) {
  return FABRIC_COLORS[patchId % FABRIC_COLORS.length];
}

function makeColorBoard() {
  return Array.from({ length: 9 }, () => Array(9).fill(null));
}

// ── Render ───────────────────────────────────────────────────

function render() {
  app.replaceChildren();
  if (appMode === 'setup') { app.appendChild(renderSetup()); return; }
  renderGame();
}

function renderSetup() {
  const gmSel = h('select', { id: 'gm' },
    h('option', { value: 'vs-ai', selected: '' }, 'vs AI'),
    h('option', { value: 'local' }, 'Local 2-Player'));
  const aiSel = h('select', { id: 'ai' },
    h('option', { value: 'easy' }, 'Easy'),
    h('option', { value: 'medium', selected: '' }, 'Medium'),
    h('option', { value: 'hard' }, 'Hard'));
  gmSel.onchange = (e) => { gameMode = e.target.value; aiSel.disabled = gameMode === 'local'; };
  aiSel.onchange = (e) => { aiDifficulty = e.target.value; };

  const startBtn = h('button', { cls: 'btn btn-primary' }, 'Start Game');
  startBtn.onclick = startGame;

  return h('div', { cls: 'setup' },
    h('div', { cls: 'setup-logo' }, 'Patchwork'),
    h('p', { cls: 'setup-sub' }, 'A game by Uwe Rosenberg'),
    h('div', { cls: 'setup-form' },
      h('label', null, 'Game Mode'), gmSel,
      h('label', null, 'AI Difficulty'), aiSel,
      startBtn));
}

function startGame() {
  game = createGame();
  appMode = 'playing';
  placingPatch = null;
  placingShape = null;
  colorBoards = [makeColorBoard(), makeColorBoard()];
  render();
}

function renderGame() {
  app.replaceChildren();
  const active = game.currentPlayer;
  const isAI = gameMode === 'vs-ai' && active === 1;

  // Header
  const turnName = isAI ? 'AI' : `Player ${active + 1}`;
  const turnBadge = h('span', { cls: `turn-badge p${active}` },
    game.phase === 'game_over' ? 'Game Over' : `${turnName}'s turn`);
  const newBtn = h('button', { cls: 'btn btn-ghost' }, 'New Game');
  newBtn.onclick = () => { appMode = 'setup'; render(); };

  app.appendChild(h('div', { cls: 'header' },
    h('div', { cls: 'header-left' }, h('span', { cls: 'logo' }, 'Patchwork'), turnBadge),
    newBtn));

  // Time Track
  app.appendChild(buildTrack());

  // Boards
  const area = h('div', { cls: 'game-area' });
  area.appendChild(buildPanel(0, active === 0));
  area.appendChild(buildPanel(1, active === 1));
  app.appendChild(area);

  // Market
  app.appendChild(buildMarket());

  // Action bar
  app.appendChild(buildActions());

  // Game Over overlay
  if (game.phase === 'game_over') app.appendChild(buildGameOver());

  // AI scheduling
  if (gameMode === 'vs-ai' && active === 1 && game.phase !== 'game_over')
    setTimeout(doAITurn, 500);
}

// ── Time Track ───────────────────────────────────────────────

function buildTrack() {
  const p0 = game.players[0].timePosition;
  const p1 = game.players[1].timePosition;
  const row = h('div', { cls: 'track-row' });
  for (let i = 0; i <= 52; i++) {
    const isInc = BUTTON_INCOME_AFTER.includes(i);
    const isSp = SPECIAL_PATCH_AFTER.includes(i) && !game.specialPatchesClaimed.includes(i);
    let cls = 'tc';
    if (isInc) cls += ' income';
    if (isSp) cls += ' special';
    const cell = h('div', { cls });
    if (p0 === i) cell.appendChild(h('div', { cls: 'tk t0' }, '1'));
    if (p1 === i) cell.appendChild(h('div', { cls: 'tk t1' }, '2'));
    cell.appendChild(h('span', { cls: 'tc-num' }, String(i)));
    row.appendChild(cell);
  }
  return h('div', { cls: 'track-card' }, row);
}

// ── Player Panel ─────────────────────────────────────────────

function buildPanel(idx, isActive) {
  const p = game.players[idx];
  const empty = countEmpty(p.board);
  const name = (gameMode === 'vs-ai' && idx === 1) ? 'AI' : `Player ${idx + 1}`;
  const isPlacing = (game.phase === 'place_patch' || game.phase === 'place_special') && game.currentPlayer === idx;

  let cls = `panel p${idx}`;
  if (isActive) cls += ' active';

  // Stats
  const stats = h('div', { cls: 'pstats' },
    h('span', { cls: 'pstat' }, h('span', { cls: 'pstat-icon btn-icon' }, 'B'), ` ${p.buttons}`),
    h('span', { cls: 'pstat' }, h('span', { cls: 'pstat-icon inc-icon' }, '+'), ` ${p.totalButtonIncome}`),
    h('span', { cls: 'pstat' }, h('span', { cls: 'pstat-icon empty-icon' }, ' '), ` ${empty} (-${empty * 2})`));
  if (p.hasSpecialTile) stats.appendChild(h('span', { cls: 'pstat', style: { color: 'var(--gold)', fontWeight: '700' } }, '7x7!'));

  // Board
  const board = h('div', { cls: 'board' });
  const cb = colorBoards[idx];
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const filled = p.board[r][c];
      const cellColor = cb ? cb[r][c] : null;

      let cellCls = 'cell';
      let cellStyle = {};

      if (filled) {
        cellStyle.background = cellColor || 'var(--border-strong)';
      } else {
        cellCls += ' empty-cell';
      }

      // Placement preview
      if (isPlacing && placingShape && game.phase === 'place_patch') {
        const sr = r - placingRow;
        const sc = c - placingCol;
        if (sr >= 0 && sr < placingShape.length && sc >= 0 && sc < placingShape[0].length && placingShape[sr][sc] >= 1) {
          if (filled) {
            cellCls += ' preview-bad';
          } else if (placingShape[sr][sc] === 2) {
            cellCls += ' preview-income';
          } else {
            cellCls += ' preview-ok';
          }
        }
      }

      // Special patch clickable
      if (game.phase === 'place_special' && game.currentPlayer === idx && !filled) {
        cellCls += ' clickable';
      }

      const cell = h('div', { cls: cellCls, style: cellStyle });

      // Show button income dot on cells that have income
      if (filled && cellColor && cb) {
        // Check if this cell is an income cell (value 2 in original shape)
        // We track this by storing a special marker
        if (cb[r][c] && cb[r][c].endsWith('!')) {
          cellStyle.background = cb[r][c].slice(0, -1);
          cell.style.background = cellStyle.background;
          cell.appendChild(h('div', { cls: 'btn-dot' }));
        }
      }

      cell.onclick = () => {
        if (game.phase === 'place_special' && idx === game.currentPlayer) doPlaceSpecial(r, c);
      };
      cell.onmouseenter = () => {
        if (game.phase === 'place_patch' && idx === game.currentPlayer && placingShape) {
          placingRow = r;
          placingCol = c;
          updatePreview();
        }
      };

      board.appendChild(cell);
    }
  }

  return h('div', { cls },
    h('div', { cls: 'panel-head' }, h('span', { cls: 'pname' }, name), stats),
    h('div', { cls: 'board-wrap' }, board));
}

// ── Market ───────────────────────────────────────────────────

function buildMarket() {
  const available = getAvailablePatches(game);
  const availSet = new Set(available.map(a => a.marketIndex));
  const player = game.players[game.currentPlayer];
  const len = game.patches.length;

  const row = h('div', { cls: 'market-row' });
  const show = Math.min(len, 14);

  for (let off = 0; off < show; off++) {
    const idx = (game.pawnIndex + off) % len;
    const patch = game.patches[idx];
    const isAvail = availSet.has(idx);
    const isPawn = off === 0;
    const afford = player.buttons >= patch.buttonCost;
    const fits = isAvail && afford ? findValidPlacements(player.board, patch.shape).length > 0 : false;
    const col = patchColor(patch.id);

    let cls = 'mpatch';
    if (isAvail) {
      cls += ' avail';
      if (!afford) cls += ' no-afford';
      else if (!fits) cls += ' no-fit';
    }

    const cols = patch.shape[0].length;
    const grid = h('div', { cls: 'mshape', style: { gridTemplateColumns: `repeat(${cols}, 14px)` } });
    for (const row2 of patch.shape) {
      for (const v of row2) {
        if (v === 0) grid.appendChild(h('div', { cls: 'mcell empty' }));
        else {
          const mc = h('div', { cls: 'mcell', style: { background: v === 2 ? darken(col, 15) : col } });
          if (v === 2) mc.appendChild(h('div', {
            style: { width: '6px', height: '6px', borderRadius: '50%', background: 'var(--gold)',
              border: '1px solid rgba(255,255,255,0.5)', position: 'absolute', top: '2px', right: '2px' },
            cls: '' }));
          mc.style.position = 'relative';
          grid.appendChild(mc);
        }
      }
    }

    const info = h('div', { cls: 'minfo' });
    info.appendChild(h('span', { cls: 'cost' }, `${patch.buttonCost}b ${patch.timeCost}t`));
    if (patch.buttonIncome > 0)
      info.appendChild(h('span', { cls: 'income-tag' }, ` +${patch.buttonIncome}`));

    const pEl = h('div', { cls }, grid, info);
    if (isPawn) pEl.appendChild(h('span', { cls: 'pawn-tag' }, 'Pawn'));

    if (isAvail && afford && fits) {
      pEl.onclick = () => {
        if (game.phase !== 'choose_action') return;
        if (gameMode === 'vs-ai' && game.currentPlayer === 1) return;
        doBuyPatch(idx);
      };
    }
    row.appendChild(pEl);
  }

  return h('div', { cls: 'market-card' },
    h('div', { cls: 'market-head' },
      h('span', { cls: 'market-title' }, 'Patch Market'),
      h('span', { cls: 'market-count' }, `${len} patches remaining`)),
    row);
}

function darken(hex, pct) {
  const n = parseInt(hex.slice(1), 16);
  const r = Math.max(0, ((n >> 16) & 255) - pct);
  const g = Math.max(0, ((n >> 8) & 255) - pct);
  const b = Math.max(0, (n & 255) - pct);
  return `rgb(${r},${g},${b})`;
}

// ── Action Bar ───────────────────────────────────────────────

function buildActions() {
  const active = game.currentPlayer;
  const isAI = gameMode === 'vs-ai' && active === 1;
  const name = isAI ? 'AI' : `Player ${active + 1}`;

  if (game.phase === 'game_over')
    return h('div', { cls: 'action-card' }, h('div', { cls: 'action-msg' }, 'Game Over'));

  if (game.phase === 'place_special') {
    const msg = isAI ? 'AI placing special patch...' : `${name}: Tap any empty cell for your free 1x1 patch`;
    return h('div', { cls: 'action-card' }, h('div', { cls: 'action-msg' }, msg));
  }

  if (game.phase === 'place_patch') {
    const rBtn = h('button', { cls: 'btn btn-secondary' }, 'Rotate', h('span', { cls: 'key-badge' }, 'R'));
    rBtn.onclick = doRotate;
    const fBtn = h('button', { cls: 'btn btn-secondary' }, 'Flip', h('span', { cls: 'key-badge' }, 'F'));
    fBtn.onclick = doFlip;
    const cBtn = h('button', { cls: 'btn btn-primary' }, 'Place', h('span', { cls: 'key-badge' }, 'Enter'));
    cBtn.onclick = doConfirm;
    if (!placingValid) cBtn.disabled = true;
    const xBtn = h('button', { cls: 'btn btn-ghost' }, 'Reset');
    xBtn.onclick = doReset;

    return h('div', { cls: 'action-card' },
      h('div', { cls: 'action-msg' }, 'Hover your board to position, then place.'),
      h('div', { cls: 'placement-bar' }, rBtn, fBtn, cBtn, xBtn));
  }

  if (isAI)
    return h('div', { cls: 'action-card' }, h('div', { cls: 'action-msg' }, 'AI thinking...'));

  const opp = game.players[1 - active];
  const me = game.players[active];
  const adv = Math.max(1, Math.min(opp.timePosition + 1, 52) - me.timePosition);

  const advBtn = h('button', { cls: 'btn btn-primary' }, `Advance (+${adv} buttons)`);
  advBtn.onclick = doAdvance;

  return h('div', { cls: 'action-card' },
    h('div', { cls: 'action-msg' }, 'Pick a patch from the market, or advance for buttons.'),
    advBtn);
}

// ── Game Over ────────────────────────────────────────────────

function buildGameOver() {
  const s0 = getScoreBreakdown(game.players[0]);
  const s1 = getScoreBreakdown(game.players[1]);
  const n0 = 'Player 1';
  const n1 = gameMode === 'vs-ai' ? 'AI' : 'Player 2';
  const winner = game.winner === 0 ? n0 : n1;

  const tbl = h('table', { cls: 'score-tbl' },
    h('tr', null, h('th'), h('th', null, n0), h('th', null, n1)),
    h('tr', null, h('td', null, 'Buttons'), h('td', null, String(s0.buttons)), h('td', null, String(s1.buttons))),
    h('tr', null, h('td', null, '7x7 Bonus'), h('td', null, `+${s0.specialTileBonus}`), h('td', null, `+${s1.specialTileBonus}`)),
    h('tr', null, h('td', null, 'Empty Squares'), h('td', null, `-${s0.emptyPenalty}`), h('td', null, `-${s1.emptyPenalty}`)),
    h('tr', { cls: 'total-row' }, h('td', null, 'Score'), h('td', null, String(s0.total)), h('td', null, String(s1.total))));

  const btn = h('button', { cls: 'btn btn-primary', style: { marginTop: '16px', padding: '10px 28px', fontSize: '1rem' } }, 'Play Again');
  btn.onclick = startGame;

  return h('div', { cls: 'overlay' },
    h('div', { cls: 'over-card' },
      h('h2', null, `${winner} Wins!`), tbl, btn));
}

// ── Actions ──────────────────────────────────────────────────

function doAdvance() {
  if (game.phase !== 'choose_action') return;
  actionAdvance(game);
  afterTurn();
}

function doBuyPatch(marketIndex) {
  if (game.phase !== 'choose_action') return;
  const player = game.players[game.currentPlayer];
  const patch = game.patches[marketIndex];
  if (player.buttons < patch.buttonCost) return;
  if (findValidPlacements(player.board, patch.shape).length === 0) return;

  const result = actionBuyPatch(game, marketIndex);
  if (result.error) return;

  placingPatch = result.patch;
  placingOrients = getOrientations(result.patch.shape);
  placingOrientIdx = 0;
  placingShape = placingOrients[0];
  placingRow = 0;
  placingCol = 0;
  placingValid = canPlace(player.board, placingShape, placingRow, placingCol);
  render();
}

function doRotate() {
  placingOrientIdx = (placingOrientIdx + 1) % placingOrients.length;
  placingShape = placingOrients[placingOrientIdx];
  updatePreview();
}

function doFlip() {
  const flipped = flipShape(placingShape);
  const key = JSON.stringify(flipped);
  const idx = placingOrients.findIndex(o => JSON.stringify(o) === key);
  if (idx >= 0) { placingOrientIdx = idx; placingShape = placingOrients[idx]; }
  else { placingOrientIdx = (placingOrientIdx + 4) % placingOrients.length; placingShape = placingOrients[placingOrientIdx]; }
  updatePreview();
}

function updatePreview() {
  const player = game.players[game.currentPlayer];
  placingValid = canPlace(player.board, placingShape, placingRow, placingCol);
  render();
}

function doConfirm() {
  if (!placingValid || !placingPatch) return;
  const pi = game.currentPlayer;
  const col = patchColor(placingPatch.id);

  // Record colors on the quilt
  for (let r = 0; r < placingShape.length; r++) {
    for (let c = 0; c < placingShape[0].length; c++) {
      if (placingShape[r][c] >= 1) {
        colorBoards[pi][placingRow + r][placingCol + c] = placingShape[r][c] === 2 ? col + '!' : col;
      }
    }
  }

  confirmPlacement(game, placingShape, placingRow, placingCol);
  placingPatch = null;
  placingShape = null;
  afterTurn();
}

function doReset() {
  placingRow = 0; placingCol = 0;
  placingOrientIdx = 0;
  if (placingOrients.length) placingShape = placingOrients[0];
  render();
}

function doPlaceSpecial(r, c) {
  const pi = game.currentPlayer;
  const result = placeSpecialPatch(game, r, c);
  if (result.error) return;
  colorBoards[pi][r][c] = SPECIAL_COLOR;
  afterTurn();
}

function afterTurn() {
  if (game.phase === 'place_special' && gameMode === 'vs-ai' && game.currentPlayer === 1) {
    while (game.pendingSpecials && game.pendingSpecials.length > 0) {
      const pos = aiPlaceSpecialPatch(game);
      colorBoards[1][pos.row][pos.col] = SPECIAL_COLOR;
      placeSpecialPatch(game, pos.row, pos.col);
    }
  }
  render();
}

function doAITurn() {
  if (game.phase === 'game_over') return;

  if (game.phase === 'place_special') {
    while (game.pendingSpecials && game.pendingSpecials.length > 0) {
      const pos = aiPlaceSpecialPatch(game);
      colorBoards[1][pos.row][pos.col] = SPECIAL_COLOR;
      placeSpecialPatch(game, pos.row, pos.col);
    }
    render();
    if (game.currentPlayer === 1 && game.phase === 'choose_action') setTimeout(doAITurn, 500);
    return;
  }

  if (game.phase !== 'choose_action' || game.currentPlayer !== 1) return;

  // Record AI patch placement colors
  const beforeBoards = game.players[1].board.map(r => [...r]);
  const { move } = executeAIMove(game, aiDifficulty);

  if (move.action === 'buy' && move.placement) {
    const col = patchColor(move.placement.shape[0] ? move.marketIndex : 0);
    // Find newly filled cells
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (game.players[1].board[r][c] && !beforeBoards[r][c]) {
          // Determine if income cell
          const sr = r - move.placement.row;
          const sc = c - move.placement.col;
          let isIncome = false;
          if (sr >= 0 && sr < move.placement.shape.length && sc >= 0 && sc < move.placement.shape[0].length) {
            isIncome = move.placement.shape[sr][sc] === 2;
          }
          const patchId = game.patches.length; // approximate
          const aiCol = FABRIC_COLORS[(patchId + r + c) % FABRIC_COLORS.length];
          colorBoards[1][r][c] = isIncome ? aiCol + '!' : aiCol;
        }
      }
    }
  }

  if (game.phase === 'place_special') {
    while (game.pendingSpecials && game.pendingSpecials.length > 0) {
      const pos = aiPlaceSpecialPatch(game);
      colorBoards[1][pos.row][pos.col] = SPECIAL_COLOR;
      placeSpecialPatch(game, pos.row, pos.col);
    }
  }

  render();
  if (game.currentPlayer === 1 && game.phase === 'choose_action') setTimeout(doAITurn, 500);
}

// ── Keyboard ─────────────────────────────────────────────────

document.addEventListener('keydown', (e) => {
  if (appMode !== 'playing' || game.phase !== 'place_patch') return;
  switch (e.key.toLowerCase()) {
    case 'r': doRotate(); break;
    case 'f': doFlip(); break;
    case 'enter': doConfirm(); break;
    case 'escape': doReset(); break;
    case 'arrowleft': e.preventDefault(); placingCol = Math.max(0, placingCol - 1); updatePreview(); break;
    case 'arrowright': e.preventDefault(); placingCol = Math.min(8, placingCol + 1); updatePreview(); break;
    case 'arrowup': e.preventDefault(); placingRow = Math.max(0, placingRow - 1); updatePreview(); break;
    case 'arrowdown': e.preventDefault(); placingRow = Math.min(8, placingRow + 1); updatePreview(); break;
  }
});

// ── Init ─────────────────────────────────────────────────────
render();
</script>
</body>
</html>
