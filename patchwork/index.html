<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Patchwork</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; overflow:hidden; background:#1a1a2e; }
canvas { display:block; margin:0 auto; }
</style>
</head>
<body>
<script type="module">
import {
  createGame, getAvailablePatches, findValidPlacements, canPlace,
  actionAdvance, actionBuyPatch, confirmPlacement, placeSpecialPatch,
  getScoreBreakdown, countEmpty, getOrientations, rotateShape,
  remainingIncomeTriggers, shapeSize,
} from './engine.js';
import { PATCHES, TRACK_LENGTH, BUTTON_INCOME_AFTER, SPECIAL_PATCH_AFTER } from './patches.js';
import { executeAIMove, aiPlaceSpecialPatch } from './ai.js';

// ── Constants ──────────────────────────────────────────────
const BOARD_SIZE = 9;
const COLORS = {
  bg: 0x1a1a2e,
  panel: 0x16213e,
  panelLight: 0x1f3460,
  cell: 0x0f3460,
  cellFilled: 0x533483,
  cellEmpty: 0x162447,
  cellHover: 0x2ecc71,
  cellInvalid: 0xe74c3c,
  accent: 0x00b4d8,
  accent2: 0xe94560,
  gold: 0xf4d03f,
  white: 0xffffff,
  textDim: 0x8899aa,
  p1: 0x00b4d8,
  p2: 0xe94560,
  income: 0xf39c12,
  special: 0x2ecc71,
};
const PATCH_FILLS = [
  0x7c3aed, 0x2563eb, 0x059669, 0xd97706, 0xdc2626,
  0x7c3aed, 0x0891b2, 0xbe185d, 0x4f46e5, 0x15803d,
  0xb45309, 0x9333ea, 0x0284c7, 0x047857, 0xc2410c,
  0xa21caf, 0x1d4ed8, 0x0d9488, 0xea580c, 0x6d28d9,
  0x0369a1, 0x166534, 0x92400e, 0x86198f, 0x1e40af,
  0x115e59, 0x9a3412, 0x6b21a8, 0x075985, 0x14532d,
  0x7c2d12, 0x701a75, 0x1e3a5f,
];

// ── Game Scene ─────────────────────────────────────────────
class GameScene extends Phaser.Scene {
  constructor() { super('Game'); }

  create() {
    this.game_state = createGame();
    this.aiDifficulty = 'medium';
    this.selectedPatchIndex = -1;
    this.currentOrientation = 0;
    this.orientations = [];
    this.dragPreview = null;
    this.isDragging = false;

    const W = this.scale.width;
    const H = this.scale.height;

    // Calculate cell size to fit board
    this.cellSize = Math.floor(Math.min((W - 40) / BOARD_SIZE, (H * 0.4) / BOARD_SIZE));
    if (this.cellSize < 28) this.cellSize = 28;
    if (this.cellSize > 42) this.cellSize = 42;
    this.cellGap = 2;

    this.drawUI();
    this.updateDisplay();
  }

  drawUI() {
    const W = this.scale.width;
    const H = this.scale.height;
    const cs = this.cellSize;
    const boardPx = cs * BOARD_SIZE + this.cellGap * (BOARD_SIZE - 1);

    // ── Top bar: scores ──
    this.topBar = this.add.container(0, 0);
    const topBg = this.add.rectangle(W/2, 25, W, 50, COLORS.panel);
    this.topBar.add(topBg);

    this.p1Label = this.add.text(12, 14, 'YOU', { fontSize: '13px', fontFamily: 'system-ui', color: '#00b4d8', fontStyle: 'bold' });
    this.p1Buttons = this.add.text(12, 30, '5 btn', { fontSize: '12px', fontFamily: 'system-ui', color: '#aabbcc' });
    this.topBar.add([this.p1Label, this.p1Buttons]);

    this.p2Label = this.add.text(W - 12, 14, 'AI', { fontSize: '13px', fontFamily: 'system-ui', color: '#e94560', fontStyle: 'bold' }).setOrigin(1, 0);
    this.p2Buttons = this.add.text(W - 12, 30, '5 btn', { fontSize: '12px', fontFamily: 'system-ui', color: '#aabbcc' }).setOrigin(1, 0);
    this.topBar.add([this.p2Label, this.p2Buttons]);

    this.turnText = this.add.text(W/2, 22, 'Your Turn', { fontSize: '14px', fontFamily: 'system-ui', color: '#ffffff', fontStyle: 'bold' }).setOrigin(0.5);
    this.topBar.add(this.turnText);

    // ── Time track (compact) ──
    const trackY = 62;
    const trackW = W - 40;
    this.add.rectangle(W/2, trackY, trackW, 8, COLORS.panelLight, 0.8).setStrokeStyle(1, 0x334466);

    // Income + special dots
    for (const pos of BUTTON_INCOME_AFTER) {
      const x = 20 + (pos / 52) * trackW;
      this.add.circle(x, trackY, 3, COLORS.income, 0.7);
    }
    for (const pos of SPECIAL_PATCH_AFTER) {
      const x = 20 + (pos / 52) * trackW;
      this.add.rectangle(x, trackY, 5, 5, COLORS.special, 0.7);
    }

    this.p1Token = this.add.circle(20, trackY, 5, COLORS.p1).setStrokeStyle(1, 0xffffff);
    this.p2Token = this.add.circle(20, trackY, 5, COLORS.p2).setStrokeStyle(1, 0xffffff);

    // ── Quilt board ──
    const boardX = Math.floor((W - boardPx) / 2);
    const boardY = 82;
    this.boardX = boardX;
    this.boardY = boardY;
    this.boardCells = [];

    for (let r = 0; r < BOARD_SIZE; r++) {
      this.boardCells[r] = [];
      for (let c = 0; c < BOARD_SIZE; c++) {
        const x = boardX + c * (cs + this.cellGap) + cs/2;
        const y = boardY + r * (cs + this.cellGap) + cs/2;
        const cell = this.add.rectangle(x, y, cs - 1, cs - 1, COLORS.cellEmpty)
          .setStrokeStyle(1, 0x223355);
        this.boardCells[r][c] = cell;
      }
    }

    // Board label
    const boardBottom = boardY + boardPx;
    this.boardLabel = this.add.text(W/2, boardBottom + 6, 'Your Board', {
      fontSize: '11px', fontFamily: 'system-ui', color: '#667788'
    }).setOrigin(0.5, 0);

    // ── Action buttons ──
    const btnY = boardBottom + 28;
    this.advanceBtn = this.createButton(W/2 - 70, btnY, 120, 34, 'ADVANCE', COLORS.accent, () => this.onAdvance());
    this.statusText = this.add.text(W/2, btnY + 46, '', {
      fontSize: '12px', fontFamily: 'system-ui', color: '#8899aa', align: 'center', wordWrap: { width: W - 30 }
    }).setOrigin(0.5, 0);

    // ── Market area ──
    const marketY = btnY + 68;
    this.marketLabel = this.add.text(12, marketY, 'MARKET', {
      fontSize: '11px', fontFamily: 'system-ui', color: '#667788', fontStyle: 'bold'
    });
    this.marketY = marketY + 18;
    this.marketCards = [];

    // ── Opponent board (small) ──
    this.oppBoardY = H - 10;
    this.oppCells = [];
    const oppSize = Math.floor(Math.min((W - 20) / BOARD_SIZE, 14));
    this.oppCellSize = oppSize;
    const oppBoardPx = oppSize * BOARD_SIZE;
    const oppX = Math.floor((W - oppBoardPx) / 2);
    this.oppBoardX = oppX;
    this.oppBoardYStart = this.oppBoardY - oppBoardPx - 16;

    this.add.text(W/2, this.oppBoardYStart - 4, 'AI Board', {
      fontSize: '10px', fontFamily: 'system-ui', color: '#556677'
    }).setOrigin(0.5, 1);

    for (let r = 0; r < BOARD_SIZE; r++) {
      this.oppCells[r] = [];
      for (let c = 0; c < BOARD_SIZE; c++) {
        const x = oppX + c * oppSize + oppSize/2;
        const y = this.oppBoardYStart + r * oppSize + oppSize/2;
        const cell = this.add.rectangle(x, y, oppSize - 1, oppSize - 1, COLORS.cellEmpty);
        this.oppCells[r][c] = cell;
      }
    }

    // ── Drag preview layer ──
    this.previewCells = [];
    this.previewContainer = this.add.container(0, 0).setDepth(100).setVisible(false);

    // ── Placement confirm button ──
    this.placeBtn = this.createButton(W/2 + 50, btnY, 100, 34, 'PLACE', COLORS.special, () => this.onConfirmPlace());
    this.placeBtn.setVisible(false);
    this.rotateBtn = this.createButton(W/2 - 50, btnY, 80, 34, 'ROTATE', COLORS.panelLight, () => this.onRotate());
    this.rotateBtn.setVisible(false);
  }

  createButton(x, y, w, h, label, color, callback) {
    const container = this.add.container(x, y);
    const bg = this.add.rectangle(0, 0, w, h, color, 0.9).setStrokeStyle(1, 0x445566);
    bg.setInteractive({ useHandCursor: true });
    const txt = this.add.text(0, 0, label, {
      fontSize: '12px', fontFamily: 'system-ui', color: '#ffffff', fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add([bg, txt]);
    bg.on('pointerdown', callback);
    container.bg = bg;
    container.label = txt;
    container.setVisible = function(v) {
      this.visible = v;
      bg.visible = v;
      txt.visible = v;
      if (v) bg.setInteractive(); else bg.disableInteractive();
      return this;
    };
    return container;
  }

  // ── Update Display ─────────────────────────────────────
  updateDisplay() {
    const gs = this.game_state;
    const W = this.scale.width;
    const trackW = W - 40;

    // Scores
    const p1 = gs.players[0], p2 = gs.players[1];
    this.p1Buttons.setText(`${p1.buttons} btn | ${countEmpty(p1.board)} empty`);
    this.p2Buttons.setText(`${p2.buttons} btn | ${countEmpty(p2.board)} empty`);

    // Time tokens
    const x1 = 20 + (p1.timePosition / 52) * trackW;
    const x2 = 20 + (p2.timePosition / 52) * trackW;
    this.tweens.add({ targets: this.p1Token, x: x1, duration: 300, ease: 'Back.easeOut' });
    this.tweens.add({ targets: this.p2Token, x: x2, duration: 300, ease: 'Back.easeOut' });

    // Turn indicator
    if (gs.phase === 'game_over') {
      const s0 = getScoreBreakdown(p1), s1 = getScoreBreakdown(p2);
      this.turnText.setText(gs.winner === 0 ? 'You Win!' : 'AI Wins!');
      this.turnText.setColor(gs.winner === 0 ? '#2ecc71' : '#e94560');
      this.statusText.setText(
        `You: ${s0.total} (${s0.buttons} btn + ${s0.specialTileBonus} tile - ${s0.emptyPenalty} penalty)\n` +
        `AI: ${s1.total} (${s1.buttons} btn + ${s1.specialTileBonus} tile - ${s1.emptyPenalty} penalty)`
      );
      this.advanceBtn.setVisible(false);
      this.hideMarket();
      return;
    }

    const isYourTurn = gs.currentPlayer === 0 && gs.phase === 'choose_action';
    this.turnText.setText(isYourTurn ? 'Your Turn' : 'AI Thinking...');
    this.turnText.setColor(isYourTurn ? '#ffffff' : '#e94560');

    // Boards
    this.renderBoard(this.boardCells, p1.board, 0);
    this.renderBoard(this.oppCells, p2.board, 1);

    // Market
    if (gs.phase === 'choose_action' && gs.currentPlayer === 0) {
      this.advanceBtn.setVisible(true);
      this.showMarket();
    } else {
      this.advanceBtn.setVisible(false);
      this.hideMarket();
    }

    // Status
    if (gs.phase === 'choose_action' && gs.currentPlayer === 0) {
      const adv = Math.min(p2.timePosition + 1 - p1.timePosition, 52 - p1.timePosition);
      this.statusText.setText(`Advance: +${Math.max(1, adv)} buttons | Or pick a patch below`);
    }
  }

  renderBoard(cells, board, playerIdx) {
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        if (board[r][c]) {
          cells[r][c].setFillStyle(playerIdx === 0 ? COLORS.cellFilled : COLORS.accent2, 1);
          cells[r][c].setStrokeStyle(1, 0x445566);
        } else {
          cells[r][c].setFillStyle(COLORS.cellEmpty, 1);
          cells[r][c].setStrokeStyle(1, 0x223355);
        }
      }
    }
  }

  // ── Market ──────────────────────────────────────────────
  showMarket() {
    this.hideMarket();
    const gs = this.game_state;
    const avail = getAvailablePatches(gs);
    const player = gs.players[0];
    const W = this.scale.width;
    const cardW = Math.floor((W - 50) / 3);
    const startX = Math.floor((W - (cardW * 3 + 20)) / 2);

    for (let i = 0; i < avail.length; i++) {
      const { patch, marketIndex } = avail[i];
      const canAfford = player.buttons >= patch.buttonCost;
      const placements = canAfford ? findValidPlacements(player.board, patch.shape) : [];
      const canBuy = placements.length > 0;

      const cx = startX + i * (cardW + 10) + cardW/2;
      const cy = this.marketY + 40;
      const container = this.add.container(cx, cy);

      // Card background
      const bg = this.add.rectangle(0, 0, cardW, 78, canBuy ? COLORS.panelLight : 0x111133, 0.9)
        .setStrokeStyle(1.5, canBuy ? COLORS.accent : 0x333355);

      // Patch shape preview
      const shape = patch.shape;
      const previewSize = Math.min(8, Math.floor((cardW - 16) / Math.max(shape[0].length, shape.length)));
      const shapeW = shape[0].length * previewSize;
      const shapeH = shape.length * previewSize;
      const shapeContainer = this.add.container(-shapeW/2, -28);
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
          if (shape[r][c] >= 1) {
            const fill = shape[r][c] === 2 ? COLORS.income : PATCH_FILLS[patch.id % PATCH_FILLS.length];
            const cell = this.add.rectangle(
              c * previewSize + previewSize/2,
              r * previewSize + previewSize/2,
              previewSize - 1, previewSize - 1, fill
            );
            shapeContainer.add(cell);
          }
        }
      }

      // Cost labels
      const costTxt = this.add.text(0, 16, `${patch.buttonCost}btn ${patch.timeCost}t`, {
        fontSize: '10px', fontFamily: 'system-ui', color: canBuy ? '#aabbcc' : '#556677'
      }).setOrigin(0.5);
      const incomeTxt = this.add.text(0, 28, patch.buttonIncome > 0 ? `+${patch.buttonIncome}/income` : '', {
        fontSize: '9px', fontFamily: 'system-ui', color: '#f39c12'
      }).setOrigin(0.5);

      container.add([bg, shapeContainer, costTxt, incomeTxt]);

      if (canBuy) {
        bg.setInteractive({ useHandCursor: true });
        bg.on('pointerdown', () => this.onSelectPatch(marketIndex, patch, i));
      }

      this.marketCards.push(container);
    }
  }

  hideMarket() {
    for (const c of this.marketCards) c.destroy();
    this.marketCards = [];
  }

  // ── Patch Selection & Placement ─────────────────────────
  onSelectPatch(marketIndex, patch, displayIdx) {
    const gs = this.game_state;
    const buyResult = actionBuyPatch(gs, marketIndex);
    if (buyResult.error) {
      this.statusText.setText(buyResult.error);
      return;
    }

    this.selectedPatchIndex = marketIndex;
    this.orientations = getOrientations(patch.shape);
    this.currentOrientation = 0;
    this.patchColor = PATCH_FILLS[patch.id % PATCH_FILLS.length];

    this.hideMarket();
    this.advanceBtn.setVisible(false);
    this.rotateBtn.setVisible(true);
    this.placeBtn.setVisible(false);
    this.statusText.setText('Drag to position, tap ROTATE, then PLACE');

    this.startPlacement();
  }

  startPlacement() {
    const shape = this.orientations[this.currentOrientation];
    this.snapRow = 0;
    this.snapCol = 0;

    // Find first valid position
    const gs = this.game_state;
    const player = gs.players[gs.currentPlayer];
    for (let r = 0; r <= BOARD_SIZE - shape.length; r++) {
      for (let c = 0; c <= BOARD_SIZE - shape[0].length; c++) {
        if (canPlace(player.board, shape, r, c)) {
          this.snapRow = r;
          this.snapCol = c;
          this.showPreview(shape, r, c);
          return;
        }
      }
    }
    this.showPreview(shape, 0, 0);
  }

  showPreview(shape, row, col) {
    // Clear previous
    this.previewContainer.removeAll(true);
    this.previewCells = [];

    const cs = this.cellSize;
    const gap = this.cellGap;
    const gs = this.game_state;
    const player = gs.players[gs.currentPlayer];
    const valid = canPlace(player.board, shape, row, col);

    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[0].length; c++) {
        if (shape[r][c] >= 1) {
          const x = this.boardX + (col + c) * (cs + gap) + cs/2;
          const y = this.boardY + (row + r) * (cs + gap) + cs/2;
          const color = valid ? this.patchColor : COLORS.cellInvalid;
          const cell = this.add.rectangle(x, y, cs - 1, cs - 1, color, 0.7)
            .setStrokeStyle(2, valid ? 0xffffff : 0xff4444);
          this.previewContainer.add(cell);
          this.previewCells.push(cell);
        }
      }
    }

    this.previewContainer.setVisible(true);
    this.placeBtn.setVisible(valid);

    // Make board cells interactive for dragging
    this.enableBoardDrag(shape);
  }

  enableBoardDrag(shape) {
    // Remove old listeners
    if (this._boardDragZone) {
      this._boardDragZone.destroy();
    }

    const cs = this.cellSize;
    const gap = this.cellGap;
    const boardPx = cs * BOARD_SIZE + gap * (BOARD_SIZE - 1);

    const zone = this.add.zone(this.boardX + boardPx/2, this.boardY + boardPx/2, boardPx + 40, boardPx + 40)
      .setInteractive({ draggable: true })
      .setDepth(50);

    this._boardDragZone = zone;

    zone.on('drag', (pointer, dragX, dragY) => {
      const col = Math.floor((pointer.x - this.boardX) / (cs + gap));
      const row = Math.floor((pointer.y - this.boardY) / (cs + gap));
      const maxR = BOARD_SIZE - shape.length;
      const maxC = BOARD_SIZE - shape[0].length;
      const clampedR = Phaser.Math.Clamp(row, 0, Math.max(0, maxR));
      const clampedC = Phaser.Math.Clamp(col, 0, Math.max(0, maxC));

      if (clampedR !== this.snapRow || clampedC !== this.snapCol) {
        this.snapRow = clampedR;
        this.snapCol = clampedC;
        this.showPreview(shape, clampedR, clampedC);
      }
    });

    // Tap on board = alternate way to position
    zone.on('pointerdown', (pointer) => {
      const col = Math.floor((pointer.x - this.boardX) / (cs + gap));
      const row = Math.floor((pointer.y - this.boardY) / (cs + gap));
      const maxR = BOARD_SIZE - shape.length;
      const maxC = BOARD_SIZE - shape[0].length;
      const clampedR = Phaser.Math.Clamp(row, 0, Math.max(0, maxR));
      const clampedC = Phaser.Math.Clamp(col, 0, Math.max(0, maxC));
      this.snapRow = clampedR;
      this.snapCol = clampedC;
      this.showPreview(shape, clampedR, clampedC);
    });
  }

  onRotate() {
    this.currentOrientation = (this.currentOrientation + 1) % this.orientations.length;
    const shape = this.orientations[this.currentOrientation];
    // Clamp snap position for new shape dimensions
    const maxR = BOARD_SIZE - shape.length;
    const maxC = BOARD_SIZE - shape[0].length;
    this.snapRow = Phaser.Math.Clamp(this.snapRow, 0, Math.max(0, maxR));
    this.snapCol = Phaser.Math.Clamp(this.snapCol, 0, Math.max(0, maxC));
    this.showPreview(shape, this.snapRow, this.snapCol);
  }

  onConfirmPlace() {
    const gs = this.game_state;
    const shape = this.orientations[this.currentOrientation];
    const result = confirmPlacement(gs, shape, this.snapRow, this.snapCol);

    if (result.error) {
      this.statusText.setText(result.error);
      return;
    }

    this.cleanupPlacement();
    this.handlePostTurn(result);
  }

  cleanupPlacement() {
    this.previewContainer.setVisible(false);
    this.previewContainer.removeAll(true);
    this.rotateBtn.setVisible(false);
    this.placeBtn.setVisible(false);
    if (this._boardDragZone) {
      this._boardDragZone.destroy();
      this._boardDragZone = null;
    }
  }

  // ── Actions ─────────────────────────────────────────────
  onAdvance() {
    const gs = this.game_state;
    if (gs.phase !== 'choose_action' || gs.currentPlayer !== 0) return;
    const result = actionAdvance(gs);
    this.handlePostTurn(result);
  }

  handlePostTurn(result) {
    const gs = this.game_state;

    // Handle special patches
    if (gs.phase === 'place_special') {
      this.handleSpecialPatches();
      return;
    }

    this.updateDisplay();

    // AI turn
    if (gs.phase === 'choose_action' && gs.currentPlayer === 1) {
      this.time.delayedCall(500, () => this.doAITurn());
    }
  }

  handleSpecialPatches() {
    const gs = this.game_state;
    if (gs.currentPlayer === 0) {
      // Player needs to place special patch
      this.statusText.setText('Tap an empty cell to place your bonus 1x1 patch');
      this.advanceBtn.setVisible(false);
      this.hideMarket();
      this.enableSpecialPatchPlacement();
    } else {
      // AI places special
      while (gs.pendingSpecials && gs.pendingSpecials.length > 0) {
        const pos = aiPlaceSpecialPatch(gs);
        placeSpecialPatch(gs, pos.row, pos.col);
      }
      this.updateDisplay();
      if (gs.phase === 'choose_action' && gs.currentPlayer === 1) {
        this.time.delayedCall(500, () => this.doAITurn());
      }
    }
  }

  enableSpecialPatchPlacement() {
    const cs = this.cellSize;
    const gap = this.cellGap;
    const gs = this.game_state;
    const player = gs.players[0];

    if (this._specialZones) {
      for (const z of this._specialZones) z.destroy();
    }
    this._specialZones = [];

    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        if (!player.board[r][c]) {
          const x = this.boardX + c * (cs + gap) + cs/2;
          const y = this.boardY + r * (cs + gap) + cs/2;
          const highlight = this.add.rectangle(x, y, cs - 1, cs - 1, COLORS.special, 0.4)
            .setStrokeStyle(1, COLORS.special)
            .setInteractive({ useHandCursor: true })
            .setDepth(50);
          highlight.on('pointerdown', () => {
            placeSpecialPatch(gs, r, c);
            for (const z of this._specialZones) z.destroy();
            this._specialZones = [];
            // More specials?
            if (gs.pendingSpecials && gs.pendingSpecials.length > 0) {
              this.enableSpecialPatchPlacement();
              this.updateDisplay();
            } else {
              this.updateDisplay();
              if (gs.phase === 'choose_action' && gs.currentPlayer === 1) {
                this.time.delayedCall(500, () => this.doAITurn());
              }
            }
          });
          this._specialZones.push(highlight);
        }
      }
    }
  }

  // ── AI ──────────────────────────────────────────────────
  doAITurn() {
    const gs = this.game_state;
    if (gs.phase !== 'choose_action' || gs.currentPlayer !== 1) return;

    const { move, result } = executeAIMove(gs, this.aiDifficulty);

    // Handle AI special patches
    if (gs.phase === 'place_special') {
      while (gs.pendingSpecials && gs.pendingSpecials.length > 0) {
        const pos = aiPlaceSpecialPatch(gs);
        placeSpecialPatch(gs, pos.row, pos.col);
      }
    }

    this.updateDisplay();

    // AI might go again (further behind on track)
    if (gs.phase === 'choose_action' && gs.currentPlayer === 1) {
      this.time.delayedCall(600, () => this.doAITurn());
    }
  }
}

// ── Phaser Config ──────────────────────────────────────────
const config = {
  type: Phaser.AUTO,
  width: Math.min(window.innerWidth, 430),
  height: window.innerHeight,
  backgroundColor: COLORS.bg,
  parent: document.body,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  },
  scene: [GameScene],
};

new Phaser.Game(config);
</script>
</body>
</html>
